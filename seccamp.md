問１

高校生の時に先輩に強制されてpython + beautifulsoupで一日かけてForbesの記事タイトルをスクレイピングするプログラムを書いたのが契機で、その後プログラミング教材のテスターのような扱いでswiftを使った簡単なアプリを作った。競技プログラミングにも少し手を出し、問題を500問程度解いたところで伸び悩んでやめた。現在は再開し、レーティング800程度。

大学に入るとともに42 Tokyoというエンジニア養成機関に所属したが、コロナウイルスの影響もありドロップアウトした。そこではC言語でprintfを書いた。他のプログラムとは違い、printfは仕様による要求が多くあるので苦労した。流れとしてはトークナイズをしてから型の情報などに基づき処理をするのだが、文字列型は文字列長の先読みができなかったり、0埋めと文字列長の固定の優先順序の指定がなかったりなどで、ごちゃごちゃとしたプログラムを書いた覚えがある。
現在は主にサークルのホームページやwikiなどをhugoやhonkitを使いながら構築しており、あまり直接コーディングはしていない。言語の処理系には興味を持っており、schemeをpythonで書くlispyは写経した。最近興味がある言語はHaskellで、型を抽象化するなどによって型に情報をもたせる点が興味深いと感じている。

問２

オーソドックスだと思うが、gccによるC言語のコンパイラについて書く。検証環境はdebian bullseyeのgcc v10.2.1。

まず、gccはファイルの中身を読んで構文チェックをして、マクロのプリプロセスをする。エラーがなければ字句解析・構文解析をして、抽象構文木を生成し、対応するアセンブリを出力、それをアセンブルしてリンク可能ファイルを出力し、標準ライブラリなどとリンクして実行可能ファイルを作るのが一連の流れである。

では、動作を検証していこう。使ったプログラムは https://github.com/phnyo/seccamp2022/examine.c にある。五行に渡って文字列を出力するだけのプログラムである。

プリプロセスのみを行ったファイルは、gccのオプション-Eで出力させると読むことができる。catしてリダイレクトしてその中身を読んでみると、typedefによる型定義と、structによる構造体の生成、関数のプロトタイプ宣言がされていて、末尾にexamine.cの中身がある。
目で読む限りこの出力されたファイルは他のヘッダファイルに依存しているわけではなく、内部で完結している。しかし、実際にstdio.hを覗いてみると、内部では他のヘッダファイルに依存している。そこで、プリプロセス時点でgccはヘッダファイルの依存関係を解決していることがわかる。また、もちろんマクロ文はないのでマクロは変数などに解決される。存在しないヘッダファイルを指定しているとエラーを吐くので、ヘッダファイルの名前解決をしていることもわかる。
そこで、プリプロセスの時点ではヘッダファイルの名前解決、マクロの展開、ヘッダファイル内の依存関係の処理をしていることがわかる。

次に、字句解析の結果を見てみる。オプションの -fdump-tree-original-raw をつけて実行することでテキストファイルにおそらく木形式を表していると考えられるファイルが出力されていることがわかる。アットマークが参照を表していると考えると、変数と関数の型情報が定義され、指定されていることがわかる。
調べたところ、この出力の際に見られる型の情報は gcc/tree.h で定義されていた。実際に中を除くとマクロがかなり多く定義されており、逐一追うのは難しかったので追ってはいない。

これで字句解析まで行っていることがわかったので、次にASTが実際に作られて出力されているところを確認したいが、GCC Internalを読んでも明確に出力方法がわからなかった。しかし、(オブジェクト)_STMTや数値トークンなどを生成しているであろうことはGCC Internalで確認できる。

入力したC言語ファイルに対応するアセンブリは -S -masm=intel -fno-asynchronous-unwind-tables オプションで出力できた。人間が書いたアセンブリではないので、プロシージャ名が簡略化されてL2、L3などになっていることが確認できる。また、変数が関数の手続きではない場所にあることがわかるとともに、puts@PLTで出力されていることがわかる。調べてみたところ、PLTはProducer Linkage Tableであり、後ほどリンカーによって動的にリンクされる関数をしまっておくテーブルのようである。また、定数をあるレジスタに固定しておくわけではなく、逐一DWORD PTRで32bitの長さの整数として-4[rbp]に代入している。おそらくこの記法は[rbp-0x4]のように4バイト分スタックポインタから引いたアドレスに代入していると考えられる。おそらく無理に変数の値をレジスタ上に確保し続けるよりも、あるレジスタに再代入を繰り返し続けた方がレジスタの枯渇を防ぐなどのメリットがあるのではないか。

次に、-c オプションをつけてリンク前のオブジェクトファイルを参照する。このファイルはバイナリなので、ファイルとして参照して中身を確認することはもはやできないが、無理やりcatで出力を見るとELFやgccなどの文字列を確認できる。また、helloという文字列が見えるので、先のexamine.cに埋め込んだ文字列がオブジェクトファイルに埋め込まれていそうであるということはわかる。これをobjdumpでディスアセンブルすると、出力したアセンブリとは違って、すべての手続きが完全に埋め込まれた状態で出てきた。これからわかるのはアセンブリはアセンブラによって実行可能ファイルになって、完全に一連の命令となることである。当たり前の事実ではあるが、バイナリに変換される前のアセンブリとバイナリに変換されたものをディスアセンブルして得たアセンブリを比べることで、実行可能ファイルの内部で手続きが一元化されていることがわかる。また、出力されたアセンブリは変数レジスタ以外の抽象的なレジスタには依存していないこともわかる。

最後に、上で得たオブジェクトファイルをリンクするが、リンク先が今回の場合特になかったので、そのまま実行可能ファイルにコンパイルされる。実行可能ファイルにはchmod +xで実行権限を与えると、C言語ファイルに書いたとおりのことが出力された。


問３

コンパイラを書く際に難しい点

一つは適切な抽象化であると感じる。gcc/tree.h のようなマクロの数では誰も実装を追えない上、テストも難しくなるだろうと予想される。そこで、適切なサイズの構造体などで抽象化したものを再度抽象化することで、可読性を上げつつデバッグもしやすいプログラムを書くことができるだろうと考えられるが、抽象化のサイズなどには基準がないため、切り分けるサイズがまちまちになり、結局可読性・メンテナンス性ともに悪化することもあると考えられる。

もう一つは再帰関数の取り扱いである。構文解析では再帰関数を用いてトークナイズ・パースを行うだろうと考えられるが、バグを埋め込んだときに見つけにくいことと、計算量が分かりづらいために採用箇所を選ぶ必要があると思う。また、文などを先読みするときに再帰関数でどのようなトークンに対してどのような操作をさせるかも問題になると考えられる。

さらに、変数のスコープ別の分離が難しくなりそうだと思う。C言語では特に文でなくともスコープを使うことができ、その中の変数はその外からは当然ながら参照できないため、スコープ内外をコンパイラ側が見分ける必要があるのが手間になりそうだ。また、グローバル変数も存在するので、管理する方法を考案するのが難しそうである。

最後に、PLTなどのリンクが難しいだろうと考えられる。結局は動的リンクを使えないとライブラリなどの恩恵を受けられないので、できれば自作のコンパイラにもそのような機能をつけたいが、Linuxのファイルシステムとアドレッシングなどに習熟した上でないと適切にリンクするようなコードをかけないのではないか。また、リンクする先を見つけるアルゴリズムもコンパイル時間のネックになりそうだ。

問４

C言語またはHaskellで書こうと思っている。できればHaskellを使いたいが、Haskellを流暢に書けるようになるためにはまだ時間が必要だと思うので、おそらくC言語になると思う。

問５

思いつくことを列挙する。

一つは組み込み変数と関数の利用である。ユーザー実装よりもコンパイラが適切な関数にリンクした方が動作が高速になるケースが存在する。また、ビット演算を多用した高速化などはユーザーに実装を任せるよりも、それらへのインターフェースをコンパイラ側が提供するのが適切である。同様に、MATH_PIなどの決まった値を処理する際に、そのような値を組み込んで提供することで、アドホックな処理方法を内部で使い、計算を高速化することができる。

もう一つはASTを吐き出すような機構を実装することである。ある形式のASTを出力し、それを与えることで、そのようなものが存在すれば、コンパイラのバックエンドをより早いものに組み替えることができる。C言語のような静的型付け言語ではない言語に関しては、その言語のASTからC言語の中間コードを生成し、それをC言語のコンパイラに与えることも考えられる。

また、構文の先読みによる変数のメモ化とアクセス回数に応じたメモリ選択でも最適化できると考えられる。例えば、再代入しない変数はconstのようにその中身に置き換えてしまえば、代入可能な変数域にその変数を置く必要はなく、ただの変数のエイリアスとして取り扱うことができる。また、mallocなどをしてもアクセス回数が多い変数をCPUにより近い実メモリ領域に取ることで、一回のアクセスにかかる時間を削減できる。

最後は遅延読み込みで、すべてのプログラムを先読みするわけではなく、都度アクセス計算することによって、計算の回数を減らすことができるのではないかと思うが、ランタイムの話だと思うので必ずしも最適化と呼べるかどうかはわからない。

問６

C言語の不便な点は、メモリアクセスが自由であるが故に、参照でSegmentation Faultやメモリリークが起こることである。

そこで、メモリ確保をする際に、ポインターではなくメモリのラッパーとなるような構造体を作り、ポインターの返り値とポインターの型、確保したメモリの大きさをその要素とすれば静的にメモリへの異常アクセスを検知できるのではないか。

その実装としては、ポインターを包むような構造体を用意するとともに、ポインターのデータへのアクセスを型と場所で検査するような関数と、ポインターへのアクセスを可能にするインターフェースを提供すれば良さそうである。
あらゆるポインターへのアクセスを複雑化するという欠点もあるが、これはポインターのゲッターのような関数を用意し、外部にはそのインターフェースを提供することで擬似的に多相化された関数を作って解決できるのではないか。

問７

もちろん自分が参加したいという気持ちは強く抱いているが、一方で自分が応募できる年代の中で最年長であることも事実である。この年としてはあまりプログラムを書く能力に秀でいるわけでもないので、もし僅差で（評価方式を全く知らないので定量的な書き方をさせていただく、悪しからず）他の応募者と自分が競るようなことがあれば、その応募者を選んでほしいと思う。若い才能に率先してチャンスを与えてほしい。

また、どのような実装になるかはわからないが、gccのバックエンドに与えられるような中間コード生成、もしくはRegister Transfer Languageを出力させることで様々なCPUプラットフォームに対応できるようなコンパイラを作りたいと考えている。

